\documentclass[11pt]{article}

\usepackage[a4paper, top=2.2cm, bottom=2.5cm, left=2.5cm, right=2.5cm]{geometry}

\usepackage{titlesec}
\titleformat{\section}
  {\normalfont\fontsize{20}{10}\bfseries}{\thesection.}{0.5em}{}
\titleformat{\subsection}
  {\normalfont\fontsize{15}{15}\bfseries}{\thesubsection.}{0.5em}{}


  
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue,bookmarksopen=true]{hyperref}
\usepackage{bookmark}
\usepackage{enumitem}
\usepackage{fancyhdr}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{setspace}
\usepackage{listings}
\usepackage{amsmath, amssymb, amsfonts}
\usepackage{url}
\usepackage{fancyvrb}
\usepackage{caption}
\graphicspath{{img/}}
\pagestyle{fancy}
\fancyhf{}
\fancyfoot[C]{\thepage}
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0.4pt}
\makeatletter
\renewcommand{\footrule}{
  \vskip12pt
  \hrule width\headwidth height\footrulewidth \vskip\footruleskip
}
\makeatother
\makeatletter
\renewcommand{\numberline}[1]{#1.\hskip0.7em}
\makeatother


\usepackage{parskip}
\setlength{\parskip}{10pt}
\setlength{\parindent}{0pt}

\begin{document}
\begin{titlepage}
  \begin{center}
    \vspace*{2cm}
    \includegraphics[width=0.65\textwidth]{login-logo.png}
    \vskip3cm
    {\Huge\bfseries Optimistic and Zero-Knowledge Rollups}\\[1em]
    {\Large\bfseries Understanding blockchain}\\[10em]
    {\large Angelo PICERNO }\\[1em]
    {\large Eduardo TEIXEIRA DE SOUSA }\\[1em]
    {\large Elena PEROTTI }\\[1em]
    {\large Micaela MASRI }\\[1em]
    {\large Adrien SEIGLE }\\[4em]
    {\small November 2025}
  \end{center}
  \vfill
\end{titlepage}

\begingroup
\setstretch{1.25}
\tableofcontents
\thispagestyle{empty}
\endgroup


\begin{spacing}{1.5}
\newpage
\section{Introduction}
The emergence and widespread adoption of blockchain technology has revealed a fundamental structural limitation: scalability. Along with decentralization and security, scalability is one of the three fundamental components of the blockchain trilemma. The trilemma states that a blockchain system can only optimize two of these three properties at the same time, forcing designers to accept trade-offs in performance or trust assumptions.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.4\linewidth]{trilemma.jpg}
    \caption{The blockchain trilemma}
    \label{fig:drawio}
\end{figure}

Interestingly, scalability challenges are not unique to blockchain systems. Traditional database architectures have long faced a comparable tension, often described as the CAP Theorem. Even though applied to different technologies, both frameworks highlight the same underlying idea: achieving perfect performance, resilience and correctness at the same time is structurally difficult, and often impossible.

Blockchain scalability can thus be understood not as an isolated limitation, but as the continuation of a broader historical challenge in distributed systems.

There are two main strategies to improve blockchain scalability. The first one is to modify the underlying blockchain architecture (Layer1, or L1). The second is to implement a second layer (L2) consisting of auxiliary technologies built on top of L1.

Among L2 solutions, Rollups (and in particular Optimistic Rollups and Zero‑Knowledge Rollups) have gained central importance because they shift most computational load
off‑chain, while preserving the security guaranteed by Layer 1.


This document examines the technical and functional characteristics of both approaches and discusses their differences, advantages and limitations, as well as potential adoption scenarios.
The goal is to assess how these mechanisms contribute to addressing the scalability challenge and to evaluate the extent to which they can offer a viable path toward more efficient and widely deployable blockchain systems.

\section{Technical Background}

In this section, we introduce the fundamental concepts necessary to understand blockchain scalability. We will review the key components of blockchain architecture, the challenges inherent to distributed ledger systems, and the mechanisms that have been proposed to enhance transaction throughput without compromising security. This background will provide the foundation for the subsequent discussion of Layer 2 solutions and Rollups.

\subsection{Scalability and Layer 1}

A Layer 1 blockchain is a foundational blockchain that processes and validates transactions independently within its own network, without relying on external systems. Examples of Layer 1 blockchains include Bitcoin, Ethereum, Solana, Aptos, and NEAR.

Several solutions have been proposed to increase the transaction processing capacity at the Layer 1 level. These include \emph{sharding}, which enables parallel validation of transactions across different shards, and modifications to the consensus protocols to make them more efficient.

\subsubsection{Sharding}

Sharding consists of dividing a blockchain into smaller, more manageable segments, called shards, which can process transactions and execute smart contracts in parallel. By distributing the computational load across multiple shards, blockchain networks can significantly improve throughput while reducing latency and resource consumption.

Unlike traditional blockchain architectures where all nodes must process every single transaction, sharding allows subsets of nodes to validate only a portion of the total transactions, thus increasing scalability.

For example, if a network of 1{,}000 nodes is divided into 10 shards of 100 nodes each, the transaction processing speed can increase by approximately a factor of ten.

An example of a sharding implementation is the NEAR Protocol, a Layer 1 blockchain that uses Nightshade. Its network is capable of processing up to 160{,}000 transactions per second (TPS), outperforming many other blockchain platforms.

While sharding improves scalability, it also introduces potential security risks. If a shard contains too few nodes or if a single shard is targeted by malicious actors, it may become easier to compromise the consensus within that shard. Therefore, blockchain designers must carefully balance shard size, the total number of shards, and mechanisms for cross-shard communication to maintain the overall security of the network.

\subsubsection{Consensus Protocols: PoW vs.\ PoS}

Another approach to improving blockchain performance is the adoption of alternative consensus protocols, which affect transaction speed, security, and energy efficiency.

\textbf{Proof of Work (PoW)} is a transaction validation algorithm based on solving computational problems, requiring network participants (miners) to perform complex cryptographic operations. PoW-based networks have significant environmental costs due to the high energy consumption associated with mining. Additionally, the need for specialized, high-performance hardware further increases the economic burden of maintaining network security.

An alternative consensus protocol, \textbf{Proof of Stake (PoS)}, does not require high computational power and significantly reduces transaction times, making it a more efficient solution compared to PoW. In PoS, instead of solving cryptographic puzzles to find the correct nonce, users must prove ownership of a certain amount of digital tokens to participate in block validation.

However, PoS introduces a potential risk of centralization: users holding a large number of tokens may exert disproportionate influence over the network, compromising decentralization.

\subsection{Scalability and Layer 2}

To improve transaction throughput and overall scalability, several Layer 2 solutions have been developed. These solutions operate as external integrations built on top of the base layer and help overcome performance limitations while preserving the security guarantees of the underlying blockchain.

Although different approaches exist, including State Channels and Sidechains, this document focuses exclusively on Rollups, a Layer 2 scalability solution designed to increase blockchain throughput and reduce transaction costs while preserving the security of Layer 1. Rollups have become the most widely adopted Layer 2 strategy, particularly for public blockchains, most notably Ethereum.

\subsubsection{Rollups}

A Rollup works by executing transactions outside the main blockchain, while still relying on it for data availability and final verification. Instead of having every node on Layer 1 process every transaction, the Rollup aggregates a large number of transactions into a single batch, computes the resulting new state, and submits only the essential data back to the Layer 1 chain. This drastically reduces the amount of computation and storage required on the base layer, which in turn increases throughput and lowers fees. Even though execution happens off chain, Layer 1 blockchain is responsible for verifying correctness through proofs or dispute mechanisms, ensuring that all state transitions produced by the Rollup are valid.

Overall, Rollups represent an effective compromise between scalability, transaction costs and security, and they are rapidly becoming one of the key technologies for improving blockchain performance.

There are two primary types of Rollups:
\begin{itemize}
  \item \textbf{Optimistic Rollups:} Transactions are assumed to be valid by default and processed off chain. If a participant detects an invalid transaction, they can submit a \emph{fraud proof} on Layer 1. The dispute is resolved using Layer 1 verification. This approach significantly reduces processing time and costs, although it introduces a waiting period (challenge window) for potential disputes.

  \item \textbf{Zero Knowledge Rollups (ZK Rollups):} Transactions are processed off chain, but for each batch, a cryptographic \emph{validity proof} is generated and published on Layer 1, which then verifies the proof to ensure it was done correctly. This proof guarantees that all transactions are correct without requiring a challenge period. ZK Rollups offer faster confirmations than Optimistic Rollups, but generating the proofs can require substantial computational resources.
\end{itemize}

These descriptions provide an overview of Rollups. In the following sections, we will explore each type in more detail, examining their mechanisms, advantages, and limitations.
\section{Optimistic Rollups}

\subsection{Operating Principle}

Optimistic Rollups are a scaling approach that involves moving transaction processing and state storage off-chain, outside the main network. Transactions are executed externally, but their related data is still recorded on the primary and official blockchain network where real transactions with economic value occur.

The system functions through operators who group multiple off-chain transactions into large batches, which are later submitted to the blockchain. This approach allows fixed costs to be distributed across many transactions within each batch, which results in reduced fees for users. Additionally, Optimistic Rollups use data compression techniques to minimize the amount of information published on-chain.

The term “optimistic” refers to the fact that these solutions assume that off-chain transactions are valid, and don't immediately require the publishing of cryptographic proofs of correctness. Instead, after a batch is submitted to the blockchain, a time window called the challenge period (which lasts roughly seven days for Ethereum) opens, during which anyone may dispute the results by providing proof of fraud.

If the challenge succeeds, the disputed transactions are replayed and the rollup state is udpdated accordingly. In this case, the sequencer (the operator who included the incorrect transaction) incurs in an economic penalty.

On the other hand, if the batch is not challenged before the challenge period ends, it is considered valid and permanently accepted by the blockchain. It's important to note that other rollup blocks may be built on top of a batch that has not yet been confirmed, however, if invalid transactions are later proven, all resulting state changes are retroactively reverted.

\subsubsection{Transaction Execution}

Users submit their transactions to validators, which are nodes that collect transactions, compress underlying data, and publish blocks to the chain.

Any node may become a validator, but doing so requires depositing a bond, similar to a Proof-of-Stake. The bond acts as financial collateral and may be slashed (partially or fully confiscated) if a validator either publishes an invalid block or builds on top of a previously invalidated block (even if the new block itself is correct). This penalty system promotes honest behavior.

Other validators in the Rollup chain locally execute the same transactions and compare their resulting state with the operator's proposed state, and if they find any discrepancies, they should initiate a challenge procedure.

\subsubsection{Publishing Blocks to the Blockchain}

After collecting transactions and building a block, the validator submits the block to the main chain as either calldata or blobs.

Calldata is a non-persistent, immutable memory area of a smart contract. Although it remains stored in blockchain history, it is not part of the blockchain's state. This means calldata is cheaper for storing data than writing directly to state, and it significantly reduces fees for users.

In Rollup systems, calldata is used to send compressed transaction data to the on-chain contract. The operator adds a new batch by invoking a specific Rollup contract function and passing the compressed data via calldata.

Like calldata, blobs are immutable and non-persistent, but they are removed from network history after about 18 days. This solution further reduces costs and improves scalability.

\subsubsection{State Commitments}

In Optimistic Rollups, the chain state is organized in a Merkle tree called the state tree. The root of this tree (the state root) represents the rollup's latest state and is stored as a hash inside the on-chain contract.

With every state transition, the validator computes a new state root, which replaces the previous one if it matches the value recorded in the contract. When a new batch is published, the validator must provide both the old and new state roots, and if the old root matches the one stored on-chain, it is replaced by the new one.

In addition to the state root, the validator must also commit to the Merkle root of the transaction batch, enabling anyone to prove the inclusion of a single transaction through a Layer 1 Merkle proof.

The Rollup contract immediately accepts new roots submitted by operators, but may later invalidate incorrect ones and restore the correct chain state.

\subsubsection{Proving Fraud}

As we previously established, Optimistic Rollups allow validators to publish blocks without providing proof of their validity, and a time window is defined during which anyone may challenge a state transition. Until then, rollup blocks are called assertions, as they may be disputed.

There are two methods of proving the vailidity of an assertion once it is challenged. The first is single-round proof, in which the disputed transactions are replayed through a verification contract in Layer 1. The second involves multiple rounds: dividing the dispute avoids full transaction re-execution on L1 which results in a reduction of costs and on-chain data requirements.

The transition from single-round to multi-round systems represents a fundamental improvement, as it maintains the same security guarantees while lowering costs and improving efficiency.

\subsection{Pros and Cons}

\begin{table}[h!]
\centering
\begin{tabular}{p{7cm} | p{7cm}}
\textbf{Pros} & \textbf{Cons} \\ \hline
Significant scalability improvements without sacrificing security or trustlessness &
Transaction finality delays due to potential fraud challenges \\ \hline

Transaction data is stored on Layer 1, improving transparency, security, censorship resistance, and decentralization &
Centralized rollup validators may influence transaction ordering \\ \hline

Fraud proving allows honest minorities to protect the chain, and fraud proof computation is accessible to regular L2 nodes &
If no honest nodes exist, a malicious operator may steal funds by publishing invalid blocks and state commitments \\ \hline

Anyone can advance the chain by executing transactions and publishing assertions &
Users must wait through the challenge period before withdrawing funds \\ \hline

Compatible with EVM and Solidity, allowing developers to deploy native Ethereum smart contracts or reuse existing tools to build new dApps &
Rollups must publish all transaction data on-chain, increasing costs \\
\end{tabular}
\caption{Pros and Cons of Optimistic Rollups}
\end{table}

\section{Zero Knowledge Rollups}
\section{Comparison Optimistic vs ZK Rollups}
\section{Conclusion}
The analysis of Optimistic Rollups and Zero-Knowledge Rollups has highlighted how both solutions represent fundamental tools for overcoming the scalability limits of Ethereum and, more generally, of public blockchains.
Optimistic Rollups, based on dispute mechanisms (fraud proofs), offer a high level of compatibility with the EVM and guarantee security through cryptoeconomic incentives, but entail longer finalization times due to the challenge periods.
ZK-Rollups, on the other hand, thanks to the use of cryptographic proofs (validity proofs), ensure immediate transaction finality and greater efficiency in resource management, although they require more specialized hardware and may involve a higher risk of operator centralization.
In general, both solutions contribute to making blockchains more scalable, reducing transaction costs and times without compromising the security and decentralization guaranteed by Layer 1. The choice between Optimistic and ZK-Rollups depends on specific needs regarding scalability, speed, and computational complexity, as well as the application context.
In the future, the evolution of Rollups, integration with sharding techniques, and improvements in validity proofs could make these solutions even more performant and accessible, paving the way for a new generation of decentralized applications with high transaction throughput and for large-scale adoption of blockchain in real-world contexts.


\end{spacing}
\end{document}
